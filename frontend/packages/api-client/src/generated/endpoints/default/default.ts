/**
 * Generated by orval v7.17.0 üç∫
 * Do not edit manually.
 * Video Frame Extractor API
 * OpenAPI spec version: 0.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  Error,
  ExtractStartBody,
  ExtractionJob,
  FrameInfo,
  FramesDownloadParams,
  FramesListParams,
  HealthCheck200,
  NotFoundError,
  VideoInfo,
  VideoUploadRequest,
  VideoUploadResponse
} from '../../models';

import { customInstance } from '../../../fetcher';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Start frame extraction job
 */
export type extractStartResponse200 = {
  data: ExtractionJob
  status: 200
}

export type extractStartResponse400 = {
  data: Error
  status: 400
}

export type extractStartResponse404 = {
  data: NotFoundError
  status: 404
}

export type extractStartResponse500 = {
  data: Error
  status: 500
}
    
export type extractStartResponseSuccess = (extractStartResponse200) & {
  headers: Headers;
};
export type extractStartResponseError = (extractStartResponse400 | extractStartResponse404 | extractStartResponse500) & {
  headers: Headers;
};

export type extractStartResponse = (extractStartResponseSuccess | extractStartResponseError)

export const getExtractStartUrl = () => {


  

  return `/api/extract`
}

export const extractStart = async (extractStartBody: ExtractStartBody, options?: RequestInit): Promise<extractStartResponse> => {
  
  return customInstance<extractStartResponse>(getExtractStartUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      extractStartBody,)
  }
);}




export const getExtractStartMutationOptions = <TError = Error | NotFoundError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractStart>>, TError,{data: ExtractStartBody}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof extractStart>>, TError,{data: ExtractStartBody}, TContext> => {

const mutationKey = ['extractStart'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractStart>>, {data: ExtractStartBody}> = (props) => {
          const {data} = props ?? {};

          return  extractStart(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractStartMutationResult = NonNullable<Awaited<ReturnType<typeof extractStart>>>
    export type ExtractStartMutationBody = ExtractStartBody
    export type ExtractStartMutationError = Error | NotFoundError

    export const useExtractStart = <TError = Error | NotFoundError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractStart>>, TError,{data: ExtractStartBody}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof extractStart>>,
        TError,
        {data: ExtractStartBody},
        TContext
      > => {

      const mutationOptions = getExtractStartMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get extraction job status
 */
export type extractGetStatusResponse200 = {
  data: ExtractionJob
  status: 200
}

export type extractGetStatusResponse404 = {
  data: NotFoundError
  status: 404
}
    
export type extractGetStatusResponseSuccess = (extractGetStatusResponse200) & {
  headers: Headers;
};
export type extractGetStatusResponseError = (extractGetStatusResponse404) & {
  headers: Headers;
};

export type extractGetStatusResponse = (extractGetStatusResponseSuccess | extractGetStatusResponseError)

export const getExtractGetStatusUrl = (jobId: string,) => {


  

  return `/api/extract/${jobId}`
}

export const extractGetStatus = async (jobId: string, options?: RequestInit): Promise<extractGetStatusResponse> => {
  
  return customInstance<extractGetStatusResponse>(getExtractGetStatusUrl(jobId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getExtractGetStatusQueryKey = (jobId?: string,) => {
    return [
    `/api/extract/${jobId}`
    ] as const;
    }

    
export const getExtractGetStatusQueryOptions = <TData = Awaited<ReturnType<typeof extractGetStatus>>, TError = NotFoundError>(jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getExtractGetStatusQueryKey(jobId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof extractGetStatus>>> = ({ signal }) => extractGetStatus(jobId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(jobId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof extractGetStatus>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ExtractGetStatusQueryResult = NonNullable<Awaited<ReturnType<typeof extractGetStatus>>>
export type ExtractGetStatusQueryError = NotFoundError


export function useExtractGetStatus<TData = Awaited<ReturnType<typeof extractGetStatus>>, TError = NotFoundError>(
 jobId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractGetStatus>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof extractGetStatus>>,
          TError,
          Awaited<ReturnType<typeof extractGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExtractGetStatus<TData = Awaited<ReturnType<typeof extractGetStatus>>, TError = NotFoundError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractGetStatus>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof extractGetStatus>>,
          TError,
          Awaited<ReturnType<typeof extractGetStatus>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useExtractGetStatus<TData = Awaited<ReturnType<typeof extractGetStatus>>, TError = NotFoundError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useExtractGetStatus<TData = Awaited<ReturnType<typeof extractGetStatus>>, TError = NotFoundError>(
 jobId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof extractGetStatus>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getExtractGetStatusQueryOptions(jobId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Cancel extraction job
 */
export type extractCancelResponse204 = {
  data: void
  status: 204
}

export type extractCancelResponse404 = {
  data: NotFoundError
  status: 404
}
    
export type extractCancelResponseSuccess = (extractCancelResponse204) & {
  headers: Headers;
};
export type extractCancelResponseError = (extractCancelResponse404) & {
  headers: Headers;
};

export type extractCancelResponse = (extractCancelResponseSuccess | extractCancelResponseError)

export const getExtractCancelUrl = (jobId: string,) => {


  

  return `/api/extract/${jobId}`
}

export const extractCancel = async (jobId: string, options?: RequestInit): Promise<extractCancelResponse> => {
  
  return customInstance<extractCancelResponse>(getExtractCancelUrl(jobId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getExtractCancelMutationOptions = <TError = NotFoundError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractCancel>>, TError,{jobId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof extractCancel>>, TError,{jobId: string}, TContext> => {

const mutationKey = ['extractCancel'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof extractCancel>>, {jobId: string}> = (props) => {
          const {jobId} = props ?? {};

          return  extractCancel(jobId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type ExtractCancelMutationResult = NonNullable<Awaited<ReturnType<typeof extractCancel>>>
    
    export type ExtractCancelMutationError = NotFoundError

    export const useExtractCancel = <TError = NotFoundError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof extractCancel>>, TError,{jobId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof extractCancel>>,
        TError,
        {jobId: string},
        TContext
      > => {

      const mutationOptions = getExtractCancelMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Get frames for a video
 */
export type framesListResponse200 = {
  data: FrameInfo[]
  status: 200
}

export type framesListResponse404 = {
  data: NotFoundError
  status: 404
}
    
export type framesListResponseSuccess = (framesListResponse200) & {
  headers: Headers;
};
export type framesListResponseError = (framesListResponse404) & {
  headers: Headers;
};

export type framesListResponse = (framesListResponseSuccess | framesListResponseError)

export const getFramesListUrl = (params: FramesListParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/frames?${stringifiedParams}` : `/api/frames`
}

export const framesList = async (params: FramesListParams, options?: RequestInit): Promise<framesListResponse> => {
  
  return customInstance<framesListResponse>(getFramesListUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFramesListQueryKey = (params?: FramesListParams,) => {
    return [
    `/api/frames`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFramesListQueryOptions = <TData = Awaited<ReturnType<typeof framesList>>, TError = NotFoundError>(params: FramesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFramesListQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof framesList>>> = ({ signal }) => framesList(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof framesList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FramesListQueryResult = NonNullable<Awaited<ReturnType<typeof framesList>>>
export type FramesListQueryError = NotFoundError


export function useFramesList<TData = Awaited<ReturnType<typeof framesList>>, TError = NotFoundError>(
 params: FramesListParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof framesList>>,
          TError,
          Awaited<ReturnType<typeof framesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFramesList<TData = Awaited<ReturnType<typeof framesList>>, TError = NotFoundError>(
 params: FramesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof framesList>>,
          TError,
          Awaited<ReturnType<typeof framesList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFramesList<TData = Awaited<ReturnType<typeof framesList>>, TError = NotFoundError>(
 params: FramesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFramesList<TData = Awaited<ReturnType<typeof framesList>>, TError = NotFoundError>(
 params: FramesListParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFramesListQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Download all frames as ZIP
 */
export type framesDownloadResponse200 = {
  data: Blob
  status: 200
}

export type framesDownloadResponse404 = {
  data: NotFoundError
  status: 404
}
    
export type framesDownloadResponseSuccess = (framesDownloadResponse200) & {
  headers: Headers;
};
export type framesDownloadResponseError = (framesDownloadResponse404) & {
  headers: Headers;
};

export type framesDownloadResponse = (framesDownloadResponseSuccess | framesDownloadResponseError)

export const getFramesDownloadUrl = (params: FramesDownloadParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/frames/download?${stringifiedParams}` : `/api/frames/download`
}

export const framesDownload = async (params: FramesDownloadParams, options?: RequestInit): Promise<framesDownloadResponse> => {
  
  return customInstance<framesDownloadResponse>(getFramesDownloadUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getFramesDownloadQueryKey = (params?: FramesDownloadParams,) => {
    return [
    `/api/frames/download`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFramesDownloadQueryOptions = <TData = Awaited<ReturnType<typeof framesDownload>>, TError = NotFoundError>(params: FramesDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesDownload>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFramesDownloadQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof framesDownload>>> = ({ signal }) => framesDownload(params, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof framesDownload>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FramesDownloadQueryResult = NonNullable<Awaited<ReturnType<typeof framesDownload>>>
export type FramesDownloadQueryError = NotFoundError


export function useFramesDownload<TData = Awaited<ReturnType<typeof framesDownload>>, TError = NotFoundError>(
 params: FramesDownloadParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesDownload>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof framesDownload>>,
          TError,
          Awaited<ReturnType<typeof framesDownload>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFramesDownload<TData = Awaited<ReturnType<typeof framesDownload>>, TError = NotFoundError>(
 params: FramesDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesDownload>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof framesDownload>>,
          TError,
          Awaited<ReturnType<typeof framesDownload>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFramesDownload<TData = Awaited<ReturnType<typeof framesDownload>>, TError = NotFoundError>(
 params: FramesDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesDownload>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFramesDownload<TData = Awaited<ReturnType<typeof framesDownload>>, TError = NotFoundError>(
 params: FramesDownloadParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof framesDownload>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFramesDownloadQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Upload a video file
 */
export type videosUploadResponse200 = {
  data: VideoUploadResponse
  status: 200
}

export type videosUploadResponse400 = {
  data: Error
  status: 400
}

export type videosUploadResponse500 = {
  data: Error
  status: 500
}
    
export type videosUploadResponseSuccess = (videosUploadResponse200) & {
  headers: Headers;
};
export type videosUploadResponseError = (videosUploadResponse400 | videosUploadResponse500) & {
  headers: Headers;
};

export type videosUploadResponse = (videosUploadResponseSuccess | videosUploadResponseError)

export const getVideosUploadUrl = () => {


  

  return `/api/videos`
}

export const videosUpload = async (videoUploadRequest: VideoUploadRequest, options?: RequestInit): Promise<videosUploadResponse> => {
  
  return customInstance<videosUploadResponse>(getVideosUploadUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      videoUploadRequest,)
  }
);}




export const getVideosUploadMutationOptions = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof videosUpload>>, TError,{data: VideoUploadRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof videosUpload>>, TError,{data: VideoUploadRequest}, TContext> => {

const mutationKey = ['videosUpload'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof videosUpload>>, {data: VideoUploadRequest}> = (props) => {
          const {data} = props ?? {};

          return  videosUpload(data,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VideosUploadMutationResult = NonNullable<Awaited<ReturnType<typeof videosUpload>>>
    export type VideosUploadMutationBody = VideoUploadRequest
    export type VideosUploadMutationError = Error

    export const useVideosUpload = <TError = Error,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof videosUpload>>, TError,{data: VideoUploadRequest}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof videosUpload>>,
        TError,
        {data: VideoUploadRequest},
        TContext
      > => {

      const mutationOptions = getVideosUploadMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * List all videos
 */
export type videosListResponse200 = {
  data: VideoInfo[]
  status: 200
}
    
export type videosListResponseSuccess = (videosListResponse200) & {
  headers: Headers;
};
;

export type videosListResponse = (videosListResponseSuccess)

export const getVideosListUrl = () => {


  

  return `/api/videos`
}

export const videosList = async ( options?: RequestInit): Promise<videosListResponse> => {
  
  return customInstance<videosListResponse>(getVideosListUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getVideosListQueryKey = () => {
    return [
    `/api/videos`
    ] as const;
    }

    
export const getVideosListQueryOptions = <TData = Awaited<ReturnType<typeof videosList>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVideosListQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof videosList>>> = ({ signal }) => videosList({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof videosList>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VideosListQueryResult = NonNullable<Awaited<ReturnType<typeof videosList>>>
export type VideosListQueryError = unknown


export function useVideosList<TData = Awaited<ReturnType<typeof videosList>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosList>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof videosList>>,
          TError,
          Awaited<ReturnType<typeof videosList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVideosList<TData = Awaited<ReturnType<typeof videosList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosList>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof videosList>>,
          TError,
          Awaited<ReturnType<typeof videosList>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVideosList<TData = Awaited<ReturnType<typeof videosList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVideosList<TData = Awaited<ReturnType<typeof videosList>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosList>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVideosListQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Get video information
 */
export type videosGetResponse200 = {
  data: VideoInfo
  status: 200
}

export type videosGetResponse404 = {
  data: NotFoundError
  status: 404
}
    
export type videosGetResponseSuccess = (videosGetResponse200) & {
  headers: Headers;
};
export type videosGetResponseError = (videosGetResponse404) & {
  headers: Headers;
};

export type videosGetResponse = (videosGetResponseSuccess | videosGetResponseError)

export const getVideosGetUrl = (videoId: string,) => {


  

  return `/api/videos/${videoId}`
}

export const videosGet = async (videoId: string, options?: RequestInit): Promise<videosGetResponse> => {
  
  return customInstance<videosGetResponse>(getVideosGetUrl(videoId),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getVideosGetQueryKey = (videoId?: string,) => {
    return [
    `/api/videos/${videoId}`
    ] as const;
    }

    
export const getVideosGetQueryOptions = <TData = Awaited<ReturnType<typeof videosGet>>, TError = NotFoundError>(videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getVideosGetQueryKey(videoId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof videosGet>>> = ({ signal }) => videosGet(videoId, { signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(videoId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof videosGet>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type VideosGetQueryResult = NonNullable<Awaited<ReturnType<typeof videosGet>>>
export type VideosGetQueryError = NotFoundError


export function useVideosGet<TData = Awaited<ReturnType<typeof videosGet>>, TError = NotFoundError>(
 videoId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosGet>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof videosGet>>,
          TError,
          Awaited<ReturnType<typeof videosGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVideosGet<TData = Awaited<ReturnType<typeof videosGet>>, TError = NotFoundError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosGet>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof videosGet>>,
          TError,
          Awaited<ReturnType<typeof videosGet>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useVideosGet<TData = Awaited<ReturnType<typeof videosGet>>, TError = NotFoundError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useVideosGet<TData = Awaited<ReturnType<typeof videosGet>>, TError = NotFoundError>(
 videoId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof videosGet>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getVideosGetQueryOptions(videoId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * Delete a video and its extracted frames
 */
export type videosDeleteResponse204 = {
  data: void
  status: 204
}

export type videosDeleteResponse404 = {
  data: NotFoundError
  status: 404
}
    
export type videosDeleteResponseSuccess = (videosDeleteResponse204) & {
  headers: Headers;
};
export type videosDeleteResponseError = (videosDeleteResponse404) & {
  headers: Headers;
};

export type videosDeleteResponse = (videosDeleteResponseSuccess | videosDeleteResponseError)

export const getVideosDeleteUrl = (videoId: string,) => {


  

  return `/api/videos/${videoId}`
}

export const videosDelete = async (videoId: string, options?: RequestInit): Promise<videosDeleteResponse> => {
  
  return customInstance<videosDeleteResponse>(getVideosDeleteUrl(videoId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}




export const getVideosDeleteMutationOptions = <TError = NotFoundError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof videosDelete>>, TError,{videoId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
): UseMutationOptions<Awaited<ReturnType<typeof videosDelete>>, TError,{videoId: string}, TContext> => {

const mutationKey = ['videosDelete'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof videosDelete>>, {videoId: string}> = (props) => {
          const {videoId} = props ?? {};

          return  videosDelete(videoId,requestOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type VideosDeleteMutationResult = NonNullable<Awaited<ReturnType<typeof videosDelete>>>
    
    export type VideosDeleteMutationError = NotFoundError

    export const useVideosDelete = <TError = NotFoundError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof videosDelete>>, TError,{videoId: string}, TContext>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof videosDelete>>,
        TError,
        {videoId: string},
        TContext
      > => {

      const mutationOptions = getVideosDeleteMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    /**
 * Health check endpoint
 */
export type healthCheckResponse200 = {
  data: HealthCheck200
  status: 200
}
    
export type healthCheckResponseSuccess = (healthCheckResponse200) & {
  headers: Headers;
};
;

export type healthCheckResponse = (healthCheckResponseSuccess)

export const getHealthCheckUrl = () => {


  

  return `/health`
}

export const healthCheck = async ( options?: RequestInit): Promise<healthCheckResponse> => {
  
  return customInstance<healthCheckResponse>(getHealthCheckUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}





export const getHealthCheckQueryKey = () => {
    return [
    `/health`
    ] as const;
    }

    
export const getHealthCheckQueryOptions = <TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
) => {

const {query: queryOptions, request: requestOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getHealthCheckQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof healthCheck>>> = ({ signal }) => healthCheck({ signal, ...requestOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type HealthCheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthCheck>>>
export type HealthCheckQueryError = unknown


export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof healthCheck>>,
          TError,
          Awaited<ReturnType<typeof healthCheck>>
        > , 'initialData'
      >, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useHealthCheck<TData = Awaited<ReturnType<typeof healthCheck>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof healthCheck>>, TError, TData>>, request?: SecondParameter<typeof customInstance>}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getHealthCheckQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




